#pragma once

#define _CRT_SECURE_NO_WARNINGS //т.к. используются ф-ции ctime

#include <iostream>
#include <string>
#include <Windows.h>
#include <list>
#include <sstream> 
#include <ctime>
#include <iomanip>
#undef max


using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::pair;
using std::list;
using std::stringstream;
using std::setw;
using std::setfill;

/*list of pair of strings*/
typedef list<pair<string, string>> lopos;

/*Функция возвращает текст ошибки по коду*/
static string errorName(int index)
{
	/*1-2 цифры: номер группы ошибки
	  3-4 фицры- номер ошибки*/
	switch (index)
	{
		/*10- работа с АВЛ деревом*/
		/*11- работа с Хэш-таблицей*/
		/*12- работа со списком*/
		/*13-Ошибки ввода*/
	case(1001): return "Ни одного клиента не зарегистрировано в программе.";
	case(1002): return "По вашему запросу не нашлось ни одного клиента";
	case(1003): return "Неверно введено водительское удостоверение";
	case(1004): return "Клиент с таким водительским удостоверением уже зарегистрирован.";
	case(1005): return "Клиент с такими паспортными данными уже зарегистрирован.";
	case(1006): return "Клиент с таким водительским удостовенением в программе не зарегистрирован.";
	case(1007): return "В ТАБЛИЦЕ СОДЕРЖАТСЯ НЕКОРРЕКТНЫЕ ДАННЫЕ!";
	case(1008): return "Нет активной аренды,связанной с данным клиентом.";

	case(1101): return "В программе не зарегистрировано ни одного автомобиля.";
	case(1102): return "По вашему запросу не нашлось ни одного автомобиля.";
	case(1103): return "Неверно введён регистрационный номер авто.";
	case(1104): return "Автомобиль с таким номером уже зарегистрирован.";
	case(1105): return "Автомобиль с таким номером не  зарегистрирован.";
	case(1106): return "Данный автомобиль уже арендуют.";
	case(1107): return "Данный автомобиль уже в ремонте.";
	case(1108): return "Данный автомобиль в данный момент не ремонтируется.";
	case(1109): return "Нет активной аренды,связанной с данным автомобилем.";

	case(1201): return "Данный клиент уже арендует автомобиль.";
	case(1202): return "В программе недостаточно данных для изменения аренды.";
	case(1203): return "Данная машина сейчас в ремонте.";
	case(1204): return "Невозможно отправить данный автомобиль в ремонт,т.к. в данный момент его кто-то арендует.";
	case(1205): return "Ни одна аренда сейчас не действительна.";
	case(1206): return "Данную машину сейчас арендуют, удаление невозможно.";
	case(1207): return "Данный клиент арендует машину- сейчас удаление невозможно.";
	case(1208): return "Для начала закройте все договоры аренды.";

	case(1301): return "Вы должны были ввести одно из предложенных значений.";
	case(1302): return "Введено некорректное значение.";
	case(1303): return "Данное значение не может быть короче 2 символов.";
	case(1304): return "Данное значение может состоять только из букв.";
	case(1305): return "В середине слова не может стоять заглавная буква.";
	case(1306): return "Введите реальное значение года производства автомобиля.";
		/*Ввод ФИО*/
	case(1307): return "ФИО может состоять минимум из трёх букв!";
	case(1308): return "В начале слова, после дефиса или пробела в ФИО должна стоять большая буква, но не \'Ъ\',\'Ь\'!";
	case(1309): return "ФИО может состоять только из букв русского алфавита и из символов дефиса и(/или) пробела.";
	case(1310): return "ФИО не может оканчиваться на что-либо кроме буквы.";
	case(1311): return "ФИО должно состоять минимум из двух слов: Имени и фамилии.";
		/*номер паспорта*/
	case(1312): return "Номер паспорта должен состоять из 10 цифр без пробелов!";

	default:
		return "Неизвестная ошибка";
	}
}
/*Функция возвращает текст предупреждения(/сообщения) по коду*/
static string warningName(int tag)
{
	/*1-2 цифры: номер группы предупреждения
	  3-4 фицры- номер прежупреждения*/
	switch (tag)
	{
		/*10- работа с АВЛ деревом*/
		/*11- работа с Хэш-таблицей*/
		/*12- работа со списком*/
		/*13-предупредения при ввода ввода*/
		/*99- общие предупреждения (для взаиможействия с программой).*/

	case(1001): return "фромат записи номера лицензии: КК ББ ЦЦЦЦЦЦ  (ввод без пробелов)\n\
		КК- код региона (цифры);\n\
		ББ – серия (буквы из следующего множества:\n\
			А, В, Е, К, М, Н, О, Р, С, Т, У, Х);\n\
		ЦЦЦЦЦЦ – порядковый номер удостоверения (цифры).";
	case(1002): return "Номер паспорта- 10 цифр, без пробелов.";

	case(1101): return "Регистрационный номер авто должен иметь вид:\n\
			«БЦЦЦББ - ЦЦ» (ввод с символом тире и без пробелов), где\n\
			Б – буква из следующего множества: А,В,Е,К,М,Н,О,Р,С,Т,У,Х; Ц - цифры.";
	case(1102): return "Найденный по запросу автомобиль:";
	case(1103): return "Найденные по запросу автомобили:";

	case(9901): return "Возвращение в меню...";
	case(9902): return "Продолжение ввода...";
	case(9903): return "Внимание! Вы не до конца ввели данные. При выходе в меню эти данные не сохранятся.";


	default: return "Неопознанное предупреждение.";
		break;
	}
}
/*Ф-ция, возвращающая строку запроса пользователю.*/
static  string askName(int tag)
{
	/*1-2 цифры: номер группы запроса
	  3-4 фицры- номер запроса*/
	switch (tag)
	{
		/*10- работа с АВЛ деревом*/
		/*11- работа с Хэш-таблицей*/
		/*12- работа со списком*/
		/*13-Мольбы о помощи*/
	case(1001): return "Введите ФИО клиента или \"0\", чтобы выйти в меню:";
	case(1002): return "Введите номер водительского удостоверения или \"0\", чтобы выйти в меню:";
	case(1003): return "Введите номер паспорта или \"0\", чтобы выйти в меню:";
	case(1004): return "Введите адрес проживания или \"0\", чтобы выйти в меню";

	case(1101): return "Введите регистрационный номер автомобиля или \"0\", чтобы выйти в меню:";
	case(1102): return "Введите марку автомобиля или \"0\", чтобы выйти в меню:";
	case(1103): return "Введите цвет автомобиля или \"0\", чтобы выйти в меню:";
		/*Без "Введите, т.к. используется в ф-ции inputAndCheck_int"*/
	case(1104): return "год выпуска автомобиля или \"0\", чтобы выйти в меню";
	case(1105): return "Вы действительно хотите удалить все автомобили, хранящиеся в программе?";
	case(1106): return "Введите регистрационный номер автомобиля для удаления:";
	case(1107): return "Вы действительно  хотите удалить сведения о данном автомобиле?";
	case(1108): return "Введите регистрационный номер автомобиля, который вы хотите отправить в ремонт:";
	case(1109): return "Введите регистрационный номер автомобиля, который вы хотите забрать из ремонта:";

	case(1201): return "Введите номер водительского удостоверения арендателя или \"0\", чтобы выйти в меню:";
	case(1202): return "Введите регистрационный номер арендуемого автомобиля или \"0\", чтобы выйти в меню:";
	case(1203): return "Введите дату начала аренды или \"0\", чтобы выйти в меню:";
	case(1204): return "Введите дату окончания аренды или \"0\", чтобы выйти в меню:";

	case(1301): return "Вы уверены, что хотите выйти?";

	default:
		return "Неизвестный запрос.";
	}
}

/*Возвращает порядковый номер выбранного действия*/
static  short int chooseDoing(string question, lopos variants)
{/*пары variants- first- что ввести, second- что произойдёт
 Это тект для восприятия пользователем.
 Не используется контейнери map, т.к. он автоматически сортирует данные,
 хранящиеся в variants*/
	string inChoice("\0"); //выбор пользователя.
	int counter; //порядковый номер, выбранного варианта.

	while (true)
	{
		cout << question << endl;
		for (auto i = variants.begin(); i != variants.end(); i++)
		{
			cout << "Введите \"" << i->first << "\"" << i->second << ".\n";
		}
		cout << "Введите значение: ";
		cin;
		getline(cin, inChoice, '\n');
		counter = 0;
		/*Поиск совпадений введённого значения с одним из предложенных*/
		for (auto i = variants.begin(); i != variants.end(); i++, counter++)
		{
			if (inChoice == i->first)
				return counter;
		}
		cout << errorName(1301) << "\nПовторите ввод!\n";
		continue;
	}
}

/*проверка ввода числа с клавиатуры.*/
static int inputAndCheck_int(string varName)
{
	int result(0);
	while (1) { //ввод до корректного значения.
		cout << "Введите " << varName << ": ";
		/*Очистка буффера ввода перед запрососом ввода*/
		/*cin.clear();
		cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');*/
		cin >> result;

		cout << endl;
		/*корректность ввода (является ли числом).*/
		if (cin.fail() || cin.peek() != '\n') {
			cin.clear();
			cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
			cout << errorName(1302) << "Введите число ещё раз!\n\n";
			continue;
		}
		break;
	}
	cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	return result;
}

/*Порверка на строку (толкьо из букв)*/
static bool isStrCorrect(string str,int* err)
{/*1. не менее 2 символов
   2. Только из букв русского алфавита
   3. В центре слова не может стоять заглавная буква.*/
	const string forbidderSymbols = { 'Ь', 'Ъ' }; //запрещённые символы для первой буквы. 
	if (str.length() < 2)
	{
		*err = 1303;
		return false;
	}
	for (int i(0); i < str.length(); i++)
	{
		/*Проверка первого символа*/
		if (!(str[0] >= 'А' && str[0] <= 'Я' || str[0] == 'Ё' ||
			str[0] >= 'а' && str[0] <= 'я' || str[0] == 'ё') ||
			int(forbidderSymbols.find(str[0])) != -1)
		{
			*err = 1304;
			return false;
		}
		/*проверка остальных символов*/
		for (int i(1); i < str.length(); i++)
		{
			/*встретилось что-то кроме мал. буквы*/
			if (!(str[i] >= 'а' && str[i] <= 'я' || str[i] == 'ё'))
			{
				*err = 1304;
				/*большая буква в середине слова*/
				if (str[i] >= 'А' && str[i] <= 'Я' || str[i] == 'Ё')
				{
					*err = 1305;
				}
				return false;
			}
		}
	}
	return true;
}
/*Корректно ли ФИО*/
static bool isNameCorrect(string city, int* error)
{/*error- возвращаемый код ошибки.*/
	bool isSignBehind(true); //флаг поднимается, если предыдущий символ был девис или пробел.
	int spaces(0);
	if (city.length() < 3) //если название слишком короткое
	{
		*error = 1307;
		return false;
	}
	for (int i(0); i < city.length(); i++) //проверка всех символов.
	{
		if (isSignBehind && !((city[i] >= 'А' && city[i] <= 'Я' || city[i] == 'Ё') && city[i] != 'Ъ' && city[i] != 'Ь' || city[i] == ' ')) //если после дефиса/ пробела не стоит б. буква
		{
			*error = 1308;
			return false;
		}
		if (!(city[i] >= 'А' && city[i] <= 'Я' || city[i] == 'Ё' || city[i] >= 'а' && city[i] <= 'я' || city[i] == 'ё'
			|| city[i] == ' ' || city[i] == '-'))                                                                     //можно только буквы, девисы и пробелы использовать.
		{
			*error = 1309;
			return false;
		}
		(city[i] == ' ' || city[i] == '-') ? (isSignBehind = true) : (isSignBehind = false);
		if (city[i] == ' ') spaces++;
	}
	if (isSignBehind) //если в конце слова не буква, а знак (деф./ проб.)
	{
		*error = 1310;
		return false;
	}
	if (spaces > 2 || spaces == 0)
	{
		*error = 1311;
		return false;
	}

	return true;
}

/*Алгоритм прямого поиска по фрагменту текста в строке*/
static int findInText(string text, string str)
{/*если фрагмент не был найден- возвращается -1*/
	int pos(0); //позиция первого символа в тексте
	bool coincidence(false);
	/*пока последний символ фрагмента не выйдет за пределы текста
	или до нахждения полного совпадения*/
	while (pos + str.length() <= text.length())
	{
		coincidence = false;
		/*проверка каждого символа фрагмента текста*/
		for (int i(0); i < str.length(); i++)
		{
			if (str[i] == text[pos + i])
				coincidence = true;
			else
			{
				coincidence = false;
				break;
			}
		}
		/*нашли фрагмент в тексте*/
		if (coincidence)
			return pos;
		/*продолжаем поиск*/
		pos++;
	}
	/*Фрагмента в тексте нет*/
	return -1;
}

